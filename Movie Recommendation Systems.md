# Movie Recommendation Systems

This project implements three different movie recommendation systems using the MovieLens ml-latest-small dataset. Each system is designed to showcase different recommendation strategies: User-User Collaborative Filtering, Popularity-Based recommendations, and a Two-Stage Retrieval + Ranking pipeline.

## Project Structure

- `data/`: Contains the MovieLens dataset files (`movies.csv`, `ratings.csv`, `tags.csv`, `links.csv`).
- `Scenario_1_User_User_CF.ipynb`: Jupyter notebook for the User-User Collaborative Filtering system.
- `Scenario_2_Popularity_Based.ipynb`: Jupyter notebook for the Popularity-Based recommendation system.
- `Scenario_3_Two_Stage_Pipeline.ipynb`: Jupyter notebook for the Two-Stage Retrieval + Ranking recommendation pipeline.
- `README.md`: This file, providing an overview and instructions.

## Setup and Installation

To run these notebooks, you need to have Python 3.8+ and Jupyter Notebook installed. You can install the required Python packages using pip:

```bash
pip install pandas numpy scikit-learn sentence-transformers matplotlib seaborn jupyter
```

## Data

The `ml-latest-small.zip` dataset was downloaded from [MovieLens](https://grouplens.org/datasets/movielens/). It contains 100,836 ratings and 3,683 tag applications across 9,742 movies by 610 users.

## Scenario 1: User-User Collaborative Filtering

**Concept:** This system finds users with similar rating patterns and recommends movies that those similar users liked but the target user hasn't seen yet. It's based on the idea that if two users rated items similarly in the past, they will likely rate other items similarly in the future.

**Implementation Details:**
- A user-item matrix is created from the `ratings.csv` file.
- Cosine similarity is used to measure the similarity between users.
- Recommendations are generated by taking a weighted average of ratings from similar users.

**How to Run:**
Open `Scenario_1_User_User_CF.ipynb` in Jupyter Notebook and run all cells.

## Scenario 2: Popularity-Based (Global Top Charts)

**Concept:** This system recommends movies based on their overall popularity, typically measured by average rating and the number of ratings. It's a simple yet effective method, especially useful for new users or when there isn't enough user-specific data.

**Implementation Details:**
- Calculates the average rating and rating count for each movie from `ratings.csv`.
- Applies a weighted rating formula (similar to IMDb's Top 250) to balance average rating with the number of votes, preventing movies with few high ratings from dominating.

**How to Run:**
Open `Scenario_2_Popularity_Based.ipynb` in Jupyter Notebook and run all cells.

## Scenario 3: Two-Stage Recommendation Pipeline (Retrieval + Ranking)

**Concept:** This advanced pipeline addresses the scalability challenges of large recommendation systems. It first retrieves a smaller set of relevant candidates and then ranks them using a more sophisticated model.

**Implementation Details:**
1.  **Data Fusion**: Combines structured movie metadata (`movies.csv`) with unstructured user tags (`tags.csv`) to create a rich textual description for each movie.
2.  **Retrieval (Candidate Generation)**: Uses a pre-trained Sentence-Transformer model (`all-MiniLM-L6-v2`) to generate semantic embeddings for movie descriptions and user queries. Cosine similarity is then used to retrieve a set of candidate movies semantically similar to the query.
3.  **Ranking (Re-ranking)**: The retrieved candidates are re-ranked using a combination of their semantic similarity score and their popularity score (calculated as in Scenario 2). This ensures both relevance and overall appeal.

**How to Run:**
Open `Scenario_3_Two_Stage_Pipeline.ipynb` in Jupyter Notebook and run all cells. Note that the first run might take some time to download the Sentence-Transformer model and generate embeddings.
